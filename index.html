<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background: #000;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      position: relative;
      font-family: monospace;
    }
    canvas {
      border: 1px solid #fff;
      touch-action: none;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    .stats {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px;
      border: 1px solid #fff;
      border-radius: 5px;
    }
    #login, #deviceSelect {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      padding: 20px;
      border: 1px solid #fff;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      text-align: center;
    }
    #deviceSelect { display: none; }
    #game { display: none; }
    .chat {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    #chatInput {
      background: #333;
      color: #fff;
      border: 1px solid #fff;
      padding: 5px;
      font-size: 14px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      width: 200px;
    }
    #sendChat {
      background: #333;
      color: #fff;
      border: 1px solid #fff;
      padding: 5px 10px;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    }
    .global-chat {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 200px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #fff;
      border-radius: 5px;
      padding: 5px;
      overflow-y: auto;
      font-size: 12px;
    }
    .global-chat-message {
      margin-bottom: 5px;
      word-wrap: break-word;
    }
    .player-list {
      position: absolute;
      top: 220px;
      right: 10px;
      width: 200px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #fff;
      border-radius: 5px;
      padding: 5px;
      font-size: 12px;
    }
    .player-list-item { margin-bottom: 3px; }
    .inventory {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    .inventory-slot {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid #fff;
      border-radius: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      text-align: center;
      cursor: pointer;
      position: relative;
    }
    .inventory-slot.selected {
      border-color: yellow;
      background: rgba(255, 255, 255, 0.4);
    }
    .inventory-slot .count {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 2px;
      border-radius: 3px;
    }
    .run-button, .spawn-button {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: #333;
      color: #fff;
      border: 1px solid #fff;
      padding: 5px 10px;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      z-index: 10;
    }
    .spawn-button {
      bottom: 50px;
    }
    @media (max-width: 600px), (orientation: landscape) {
      #chatInput { width: 150px; font-size: 12px; }
      #sendChat { padding: 5px; font-size: 12px; }
      .inventory-slot { width: 40px; height: 40px; font-size: 10px; }
      .inventory-slot .count { font-size: 8px; }
      .chat { bottom: 70px; }
      .inventory { bottom: 10px; }
      .global-chat { width: 150px; height: 150px; font-size: 10px; }
      .player-list { width: 150px; font-size: 10px; top: 170px; }
      .run-button { bottom: 60px; right: 10px; }
      .spawn-button { bottom: 100px; right: 10px; }
    }
    @media (min-width: 601px) {
      .chat { bottom: 100px; }
      .inventory { bottom: 40px; }
      .run-button { bottom: 40px; right: 10px; }
      .spawn-button { bottom: 80px; right: 10px; }
    }
  </style>
</head>
<body>
  <div id="login">
    <input type="text" id="nameInput" placeholder="как звать путник?" maxlength="10">
    <button onclick="proceedToDeviceSelect()">играть</button>
  </div>
  <div id="deviceSelect">
    <p>Ты с чем сидишь?</p>
    <button onclick="selectDevice('pc')">ПК</button>
    <button onclick="selectDevice('mobile')">Мобила</button>
  </div>
  <div id="game">
    <canvas id="gameCanvas"></canvas>
    <div class="stats" id="stats">Здоровье: 100 | Энергия: 100 | Скорость: Обычная</div>
    <div class="chat">
      <input type="text" id="chatInput" placeholder="начать базарить" maxlength="50">
      <button id="sendChat">ГАФ</button>
    </div>
    <div class="global-chat" id="globalChat"></div>
    <div class="player-list" id="playerList"></div>
    <div class="inventory" id="inventory"></div>
    <button class="run-button" id="runButton">Бег</button>
    <button class="spawn-button" id="spawnButton">Спавн</button>
  </div>
  <audio id="runSound" src="https://www.myinstants.com/media/sounds/running.mp3"></audio>
  <script src="/items.js"></script>
  <script>
    // Константы
    const GRID_SIZE = 15;
    const MAX_ARROWS = 50;
    const MAX_ENERGY = 100;
    const MESSAGE_LIFETIME = 30000;
    const CHAT_MESSAGE_LIFETIME = 10000;

    // DOM-элементы (кэшируем)
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d", { alpha: false });
    ctx.imageSmoothingEnabled = true;
    const statsEl = document.getElementById("stats");
    const chatInput = document.getElementById("chatInput");
    const globalChatEl = document.getElementById("globalChat");
    const playerListEl = document.getElementById("playerList");
    const inventoryEl = document.getElementById("inventory");
    const runButton = document.getElementById("runButton");
    const spawnButton = document.getElementById("spawnButton");
    const runSound = document.getElementById("runSound");

    // Глобальные переменные
    let deviceType = null;
    let canvasPx = 0;
    let cellPx = 0;
    const tiles = new Map();
    const players = new Map();
    const messages = new Map();
    let globalMessages = [];
    const arrows = [];
    let myId = null;
    let selectedSlot = null;
    let inventory = getItems();
    let path = [];
    let needsRedraw = false;
    let gridCache = null;
    let energy = 100;
    let isRunning = false;
    let moveCooldown = 250;
    let lastMoveTime = 0;
    let lastUpdateTime = 0;
    let isGameLoopRunning = false;
    let spawnPosition = { x: 0, y: 0 };
    let playerPositionsCache = new Map();
    let statsCache = '';

    const ws = new WebSocket('wss://' + window.location.hostname + '/ws');
    ws.onopen = () => {};
    ws.onmessage = (message) => {
      const data = JSON.parse(message.data);
      if (data.type === 'init') {
        myId = data.id;
        Object.entries(data.players).forEach(([id, player]) => {
          players.set(id, player);
          playerPositionsCache.set(id, { x: player.x, y: player.y });
        });
        Object.entries(data.tiles).forEach(([key, value]) => tiles.set(key, value));
        inventory[0].count = players.get(myId).blocks || 0;
        const me = players.get(myId);
        spawnPosition = { x: me.x, y: me.y };
        updatePlayerList();
        needsRedraw = true;
      } else if (data.type === 'batch') {
        let playersChanged = false;
        let tilesChanged = false;
        data.updates.forEach((update) => {
          if (update.type === 'join') {
            players.set(update.id, update.player);
            playerPositionsCache.set(update.id, { x: update.player.x, y: update.player.y });
            playersChanged = true;
          } else if (update.type === 'updatePlayer') {
            const prevPos = playerPositionsCache.get(update.id);
            players.set(update.id, update.player);
            playerPositionsCache.set(update.id, { x: update.player.x, y: update.player.y });
            if (update.id === myId) inventory[0].count = update.player.blocks || 0;
            if (prevPos.x !== update.player.x || prevPos.y !== update.player.y) playersChanged = true;
          } else if (update.type === 'updateTile') {
            tiles.set(update.x + "," + update.y, update.value);
            gridCache = null;
            tilesChanged = true;
          } else if (update.type === 'leave') {
            players.delete(update.id);
            messages.delete(update.id);
            playerPositionsCache.delete(update.id);
            playersChanged = true;
          } else if (update.type === 'chat') {
            const { id, text, timestamp } = update;
            const player = players.get(id);
            if (player) {
              globalMessages.push({ id, name: player.name, text, timestamp });
              updateGlobalChat();
              setTimeout(() => {
                globalMessages = globalMessages.filter(m => m.timestamp !== timestamp);
                updateGlobalChat();
              }, MESSAGE_LIFETIME);
            }
            if (!messages.has(id)) messages.set(id, []);
            messages.get(id).push({ text, timestamp });
            setTimeout(() => {
              const playerMessages = messages.get(id);
              if (playerMessages) {
                const index = playerMessages.findIndex(m => m.timestamp === timestamp);
                if (index !== -1) playerMessages.splice(index, 1);
                if (playerMessages.length === 0) messages.delete(id);
              }
            }, CHAT_MESSAGE_LIFETIME);
          } else if (update.type === 'arrow') {
            if (arrows.length < MAX_ARROWS) {
              arrows.push({
                x: update.x,
                y: update.y,
                targetX: update.targetX,
                targetY: update.targetY,
                startTime: Date.now(),
                shooterId: update.shooterId,
                currentX: update.x,
                currentY: update.y,
                path: calculatePath(update.x, update.y, update.targetX, update.targetY)
              });
            }
          }
        });
        if (playersChanged || tilesChanged) needsRedraw = true;
      }
    };
    ws.onclose = () => {};

    function proceedToDeviceSelect() {
      const name = document.getElementById('nameInput').value.trim();
      if (name) {
        ws.send(JSON.stringify({ type: 'setName', name }));
        document.getElementById('login').style.display = 'none';
        document.getElementById('deviceSelect').style.display = 'block';
      }
    }

    function selectDevice(type) {
      deviceType = type;
      canvasPx = type === 'pc' ? 600 : 450;
      cellPx = canvasPx / GRID_SIZE;
      canvas.width = canvasPx;
      canvas.height = canvasPx;
      document.getElementById('deviceSelect').style.display = 'none';
      document.getElementById('game').style.display = 'block';
      renderInventory();
      needsRedraw = true;
      if (!isGameLoopRunning) {
        isGameLoopRunning = true;
        gameLoop();
      }
    }

    function nearby(x1, y1, x2, y2, range = 1) {
      return Math.abs(x1 - x2) <= range && Math.abs(y1 - y2) <= range && (x1 !== x2 || y1 !== y2);
    }

    function getCell(x, y) {
      return tiles.get(x + "," + y) || 0;
    }

    function findPath(startX, startY, targetX, targetY) {
      const queue = [{ x: startX, y: startY, path: [] }];
      const visited = new Set([startX + "," + startY]);
      const directions = [
        { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
        { dx: -1, dy: 0 }, { dx: 1, dy: 0 },
        { dx: -1, dy: -1 }, { dx: 1, dy: -1 },
        { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
      ];
      let iterations = 0;
      const maxIterations = 500;
      while (queue.length && iterations++ < maxIterations) {
        const { x, y, path } = queue.shift();
        if (x === targetX && y === targetY) return path.concat({ x, y });
        for (const { dx, dy } of directions) {
          const nextX = x + dx, nextY = y + dy;
          const key = nextX + "," + nextY;
          if (!visited.has(key) && getCell(nextX, nextY) !== 1) {
            visited.add(key);
            queue.push({ x: nextX, y: nextY, path: path.concat({ x, y }) });
          }
        }
      }
      return [];
    }

    function moveAlongPath() {
      const me = players.get(myId);
      if (!me || !path.length) return;
      const now = Date.now();
      if (now - lastMoveTime < moveCooldown) return;
      lastMoveTime = now;
      const nextPos = path.shift();
      if (getCell(nextPos.x, nextPos.y) === 0) {
        if (isRunning && energy >= 4) {
          energy -= 4;
          moveCooldown = 100;
          runSound.currentTime = 0;
          runSound.play().catch(() => {});
        } else {
          moveCooldown = 250;
        }
        ws.send(JSON.stringify({ type: 'move', x: nextPos.x, y: nextPos.y }));
        needsRedraw = true;
      } else {
        path = [];
      }
    }

    function calculatePath(startX, startY, targetX, targetY) {
      const path = [];
      const dx = targetX - startX, dy = targetY - startY;
      const steps = Math.max(Math.abs(dx), Math.abs(dy));
      if (!steps) return path;
      const xStep = dx / steps, yStep = dy / steps;
      let x = startX, y = startY;
      for (let i = 0; i < steps; i++) {
        x += xStep;
        y += yStep;
        path.push({ x: Math.round(x), y: Math.round(y) });
      }
      return path;
    }

    function updateArrows() {
      const me = players.get(myId);
      if (!me) return;
      const now = Date.now();
      let arrowsChanged = false;
      for (let i = arrows.length - 1; i >= 0; i--) {
        const arrow = arrows[i];
        const elapsed = (now - arrow.startTime) / 1000;
        if (elapsed > 10 || !arrow.path.length) {
          arrows.splice(i, 1);
          arrowsChanged = true;
          continue;
        }
        const nextPos = arrow.path.shift();
        arrow.currentX = nextPos.x;
        arrow.currentY = nextPos.y;
        if (tiles.get(arrow.currentX + "," + arrow.currentY) === 1) {
          arrows.splice(i, 1);
          arrowsChanged = true;
          continue;
        }
        for (const [id, player] of players) {
          if (id === arrow.shooterId) continue;
          if (Math.abs(player.x - arrow.currentX) <= 0.5 && Math.abs(player.y - arrow.currentY) <= 0.5) {
            ws.send(JSON.stringify({ type: 'damage', targetId: id, damage: 10 }));
            arrows.splice(i, 1);
            arrowsChanged = true;
            break;
          }
        }
      }
      if (arrowsChanged) needsRedraw = true;
    }

    function regenerateEnergy(delta) {
      if (!players.get(myId)) return;
      const newEnergy = Math.min(MAX_ENERGY, energy + (path.length ? 4 : 8) / 1000 * delta);
      if (newEnergy !== energy) {
        energy = newEnergy;
        needsRedraw = true;
      }
    }

    function updateStats() {
      const me = players.get(myId);
      if (!me) return;
      const newStats = `Здоровье: ${me.hp} | Энергия: ${Math.floor(energy)} | Скорость: ${isRunning ? 'Бег' : 'Обычная'}`;
      if (newStats !== statsCache) {
        statsCache = newStats;
        statsEl.innerText = statsCache;
      }
    }

    function wrapText(text, maxWidth) {
      const words = text.split('');
      const lines = [];
      let currentLine = '';
      for (const char of words) {
        const testLine = currentLine + char;
        if (ctx.measureText(testLine).width > maxWidth && currentLine) {
          lines.push(currentLine);
          currentLine = char;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) lines.push(currentLine);
      return lines;
    }

    function drawGrid(sx, sy) {
      const cacheKey = `${sx},${sy}`;
      if (!gridCache || gridCache.key !== cacheKey) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = canvasPx;
        offscreenCanvas.height = canvasPx;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        offscreenCtx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        offscreenCtx.lineWidth = 1;
        for (let ty = 0; ty < GRID_SIZE; ty++) {
          for (let tx = 0; tx < GRID_SIZE; tx++) {
            const wx = sx + tx, wy = sy + ty;
            const xPx = tx * cellPx, yPx = ty * cellPx;
            offscreenCtx.strokeRect(xPx, yPx, cellPx, cellPx);
            if (tiles.get(wx + "," + wy) === 1) {
              offscreenCtx.fillStyle = "rgba(255, 255, 255, 0.9)";
              offscreenCtx.fillRect(xPx + 2, yPx + 2, cellPx - 4, cellPx - 4);
            }
          }
        }
        gridCache = { key: cacheKey, canvas: offscreenCanvas };
      }
      ctx.drawImage(gridCache.canvas, 0, 0);
    }

    function draw() {
      const me = players.get(myId);
      if (!me) return;
      ctx.clearRect(0, 0, canvasPx, canvasPx);
      const sx = me.x - Math.floor(GRID_SIZE / 2);
      const sy = me.y - Math.floor(GRID_SIZE / 2);
      drawGrid(sx, sy);

      for (const arrow of arrows) {
        const px1 = (arrow.currentX - sx) * cellPx + cellPx / 2;
        const py1 = (arrow.currentY - sy) * cellPx + cellPx / 2;
        let px2 = px1, py2 = py1;
        if (arrow.path.length) {
          const nextPos = arrow.path[0];
          px2 = (nextPos.x - sx) * cellPx + cellPx / 2;
          py2 = (nextPos.y - sy) * cellPx + cellPx / 2;
        }
        if (px1 >= 0 && px1 <= canvasPx && py1 >= 0 && py1 <= canvasPx) {
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(px1, py1);
          ctx.lineTo(px2, py2);
          ctx.stroke();
        }
      }

      for (const [id, player] of players) {
        const px = (player.x - sx) * cellPx + cellPx / 2;
        const py = (player.y - sy) * cellPx + cellPx / 2;
        if (px < 0 || px > canvasPx || py < 0 || py > canvasPx) continue;
        ctx.save();
        ctx.translate(px, py);
        if (id === myId && isRunning) {
          ctx.scale(1.2, 1.2);
        }
        ctx.fillStyle = player.color;
        ctx.font = "26px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("@", 0, 0);
        ctx.restore();
        if (player.name) {
          ctx.font = "12px monospace";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.fillText(player.name, px, py - 20);
          ctx.fillText(`Здоровье: ${player.hp}`, px, py - 35);
        }
      }

      for (const [id, player] of players) {
        const px = (player.x - sx) * cellPx + cellPx / 2;
        const py = (player.y - sy) * cellPx + cellPx / 2;
        if (px < 0 || px > canvasPx || py < 0 || py > canvasPx || !messages.has(id)) continue;
        const playerMessages = messages.get(id);
        const maxWidth = cellPx * 3;
        let totalHeight = 0;
        const lineHeight = 15;
        for (const msg of playerMessages) totalHeight += wrapText(msg.text, maxWidth).length * lineHeight + 10;
        let currentY = py - 50 - totalHeight;
        for (const msg of playerMessages) {
          const lines = wrapText(msg.text, maxWidth);
          const boxHeight = lines.length * lineHeight + 10;
          const boxWidth = maxWidth + 10;
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.strokeStyle = "white";
          ctx.lineWidth = 1;
          ctx.fillRect(px - boxWidth / 2, currentY, boxWidth, boxHeight);
          ctx.strokeRect(px - boxWidth / 2, currentY, boxWidth, boxHeight);
          ctx.font = "12px monospace";
          ctx.fillStyle = "white";
          ctx.textBaseline = "middle";
          lines.forEach((line, j) => ctx.fillText(line, px, currentY + 5 + (j + 0.5) * lineHeight));
          currentY += boxHeight + 5;
        }
      }

      const slots = inventoryEl.querySelectorAll('.inventory-slot');
      for (let i = 0; i < slots.length; i++) {
        const countEl = slots[i].querySelector('.count');
        if (countEl) countEl.innerText = inventory[i].count || 0;
      }
    }

    let chatUpdatePending = false;
    function updateGlobalChat() {
      if (chatUpdatePending) return;
      chatUpdatePending = true;
      requestAnimationFrame(() => {
        globalChatEl.innerText = globalMessages.map(msg => `${msg.name}: ${msg.text}`).join('\n');
        globalChatEl.scrollTop = globalChatEl.scrollHeight;
        chatUpdatePending = false;
      });
    }

    let playerListUpdatePending = false;
    function updatePlayerList() {
      if (playerListUpdatePending) return;
      playerListUpdatePending = true;
      requestAnimationFrame(() => {
        const playerNames = Array.from(players.values())
          .filter(player => player.name && player.name.trim() !== '')
          .map(player => player.name);
        playerListEl.innerText = playerNames.length ? `Игроки:\n${playerNames.join('\n')}` : 'Игроки:\n(нет игроков)';
        playerListUpdatePending = false;
      });
    }

    function renderInventory() {
      inventory.forEach((item, index) => {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.dataset.slot = index;
        slot.innerHTML = `<span>${item.name}</span>` + (item.count !== undefined ? `<span class="count">${item.count}</span>` : '');
        slot.addEventListener('click', () => {
          if (selectedSlot === index) {
            selectedSlot = null;
            slot.classList.remove('selected');
          } else {
            selectedSlot = index;
            inventoryEl.querySelectorAll('.inventory-slot').forEach(s => s.classList.remove('selected'));
            slot.classList.add('selected');
          }
        });
        inventoryEl.appendChild(slot);
      });
    }

    function canvasMouseDown(e) {
      const me = players.get(myId);
      if (!me) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const tx = Math.floor(x / cellPx);
      const ty = Math.floor(y / cellPx);
      const targetX = me.x - Math.floor(GRID_SIZE / 2) + tx;
      const targetY = me.y - Math.floor(GRID_SIZE / 2) + ty;
      if (selectedSlot === null) {
        path = findPath(me.x, me.y, targetX, targetY);
      } else {
        inventory[selectedSlot].action(me, targetX, targetY, ws, nearby, getCell, inventory, players, myId);
      }
    }

    document.getElementById('sendChat').addEventListener('click', () => {
      const text = chatInput.value.trim();
      if (text) {
        ws.send(JSON.stringify({ type: 'chat', text }));
        chatInput.value = '';
      }
    });

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const text = chatInput.value.trim();
        if (text) {
          ws.send(JSON.stringify({ type: 'chat', text }));
          chatInput.value = '';
        }
      }
    });

    runButton.addEventListener('click', () => {
      isRunning = !isRunning;
      runButton.innerText = isRunning ? 'Ходьба' : 'Бег';
      moveCooldown = isRunning ? 100 : 250;
      needsRedraw = true;
    });

    spawnButton.addEventListener('click', () => {
      const me = players.get(myId);
      if (!me) return;
      ws.send(JSON.stringify({ type: 'move', x: spawnPosition.x, y: spawnPosition.y }));
      path = [];
      needsRedraw = true;
    });

    document.addEventListener('keydown', (e) => {
      const activeElement = document.activeElement;
      if (activeElement.tagName === 'INPUT' && (activeElement.id === 'nameInput' || activeElement.id === 'chatInput')) return;
      if (e.key === 'q' || e.key === 'Q') {
        chatInput.focus();
      }
      if (['1', '2', '3', '4', '5'].includes(e.key)) {
        e.preventDefault();
        const index = parseInt(e.key) - 1;
        if (selectedSlot === index) {
          selectedSlot = null;
          inventoryEl.querySelector(`.inventory-slot[data-slot="${index}"]`).classList.remove('selected');
        } else {
          selectedSlot = index;
          inventoryEl.querySelectorAll('.inventory-slot').forEach(slot => slot.classList.remove('selected'));
          inventoryEl.querySelector(`.inventory-slot[data-slot="${index}"]`).classList.add('selected');
        }
      }
    });

    canvas.onmousedown = canvasMouseDown;
    canvas.ontouchstart = (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      canvas.dispatchEvent(new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
      }));
    };

    function gameLoop(timestamp) {
      if (!lastUpdateTime) lastUpdateTime = timestamp;
      const delta = timestamp - lastUpdateTime;
      lastUpdateTime = timestamp;

      moveAlongPath();
      updateArrows();
      regenerateEnergy(delta);
      updateStats();
      if (needsRedraw) {
        draw();
        needsRedraw = false;
      }
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
