<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background: #000;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      position: relative;
      font-family: monospace;
    }
    canvas {
      border: 1px solid #fff;
      touch-action: none;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    .stats {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px;
      border: 1px solid #fff;
      border-radius: 5px;
    }
    #login, #deviceSelect {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      padding: 20px;
      border: 1px solid #fff;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      text-align: center;
    }
    #deviceSelect { display: none; }
    #game { display: none; }
    .chat {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    #chatInput {
      background: #333;
      color: #fff;
      border: 1px solid #fff;
      padding: 5px;
      font-size: 14px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      width: 200px;
    }
    #sendChat {
      background: #333;
      color: #fff;
      border: 1px solid #fff;
      padding: 5px 10px;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    }
    .global-chat {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 200px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #fff;
      border-radius: 5px;
      padding: 5px;
      overflow-y: auto;
      font-size: 12px;
    }
    .global-chat-message {
      margin-bottom: 5px;
      word-wrap: break-word;
    }
    .player-list {
      position: absolute;
      top: 220px;
      right: 10px;
      width: 200px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #fff;
      border-radius: 5px;
      padding: 5px;
      font-size: 12px;
    }
    .player-list-item { margin-bottom: 3px; }
    .inventory {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    .inventory-slot {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid #fff;
      border-radius: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      text-align: center;
      cursor: pointer;
      position: relative;
    }
    .inventory-slot.selected {
      border-color: yellow;
      background: rgba(255, 255, 255, 0.4);
    }
    .inventory-slot .count {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 2px;
      border-radius: 3px;
    }
    .run-button {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: #333;
      color: #fff;
      border: 1px solid #fff;
      padding: 5px 10px;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      z-index: 10;
    }
    @media (max-width: 600px), (orientation: landscape) {
      #chatInput { width: 150px; font-size: 12px; }
      #sendChat { padding: 5px; font-size: 12px; }
      .inventory-slot { width: 40px; height: 40px; font-size: 10px; }
      .inventory-slot .count { font-size: 8px; }
      .chat { bottom: 70px; }
      .inventory { bottom: 10px; }
      .global-chat { width: 150px; height: 150px; font-size: 10px; }
      .player-list { width: 150px; font-size: 10px; top: 170px; }
      .run-button { bottom: 60px; right: 10px; }
    }
    @media (min-width: 601px) {
      .chat { bottom: 100px; }
      .inventory { bottom: 40px; }
      .run-button { bottom: 40px; right: 10px; }
    }
  </style>
</head>
<body>
  <div id="login">
    <input type="text" id="nameInput" placeholder="как звать путник?" maxlength="10">
    <button onclick="proceedToDeviceSelect()">играть</button>
  </div>
  <div id="deviceSelect">
    <p>Ты с чем сидишь?</p>
    <button onclick="selectDevice('pc')">ПК</button>
    <button onclick="selectDevice('mobile')">Мобила</button>
  </div>
  <div id="game">
    <canvas id="gameCanvas"></canvas>
    <div class="stats" id="stats">Здоровье: 100 | Энергия: 100 | Скорость: Обычная</div>
    <div class="chat">
      <input type="text" id="chatInput" placeholder="начать базарить" maxlength="50">
      <button id="sendChat">ГАФ</button>
    </div>
    <div class="global-chat" id="globalChat"></div>
    <div class="player-list" id="playerList"></div>
    <div class="inventory" id="inventory"></div>
    <button class="run-button" id="runButton">Бег</button>
  </div>
  <script src="/items.js"></script>
  <script>
    const gridSize = 15;
    let deviceType = null;
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    const tiles = new Map();
    const players = new Map();
    const messages = new Map();
    let globalMessages = [];
    const arrows = [];
    const maxArrows = 50;
    let myId = null;
    let selectedSlot = null;
    let inventory = getItems();
    let path = [];
    let needsRedraw = false;
    let gridCache = null;
    let energy = 100;
    const maxEnergy = 100;
    let isRunning = false;
    let moveCooldown = 250;
    let lastMoveTime = 0;
    let lastUpdateTime = 0;
    let isGameLoopRunning = false; // Флаг для предотвращения множественных вызовов gameLoop

    const ws = new WebSocket('wss://' + window.location.hostname + '/ws');
    ws.onopen = () => {};
    ws.onmessage = (message) => {
      const data = JSON.parse(message.data);
      if (data.type === 'init') {
        myId = data.id;
        Object.entries(data.players).forEach(([id, player]) => players.set(id, player));
        Object.entries(data.tiles).forEach(([key, value]) => tiles.set(key, value));
        inventory[0].count = players.get(myId).blocks || 0;
        updatePlayerList();
        needsRedraw = true;
      } else if (data.type === 'batch') {
        data.updates.forEach((update) => {
          if (update.type === 'join') {
            players.set(update.id, update.player);
            updatePlayerList();
          } else if (update.type === 'updatePlayer') {
            players.set(update.id, update.player);
            if (update.id === myId) inventory[0].count = update.player.blocks || 0;
          } else if (update.type === 'updateTile') {
            tiles.set(update.x + "," + update.y, update.value);
            gridCache = null;
          } else if (update.type === 'leave') {
            players.delete(update.id);
            messages.delete(update.id);
            updatePlayerList();
          } else if (update.type === 'chat') {
            const { id, text, timestamp } = update;
            const player = players.get(id);
            if (player) {
              globalMessages.push({ id, name: player.name, text, timestamp });
              updateGlobalChat();
              setTimeout(() => {
                globalMessages = globalMessages.filter(m => m.timestamp !== timestamp);
                updateGlobalChat();
              }, 30000);
            }
            if (!messages.has(id)) messages.set(id, []);
            messages.get(id).push({ text, timestamp });
            setTimeout(() => {
              const playerMessages = messages.get(id);
              if (playerMessages) {
                const index = playerMessages.findIndex(m => m.timestamp === timestamp);
                if (index !== -1) playerMessages.splice(index, 1);
                if (playerMessages.length === 0) messages.delete(id);
              }
            }, 10000);
          } else if (update.type === 'arrow') {
            if (arrows.length < maxArrows) {
              arrows.push({
                x: update.x,
                y: update.y,
                targetX: update.targetX,
                targetY: update.targetY,
                startTime: Date.now(),
                shooterId: update.shooterId,
                currentX: update.x,
                currentY: update.y,
                path: calculatePath(update.x, update.y, update.targetX, update.targetY)
              });
            }
          }
        });
        needsRedraw = true;
      }
    };
    ws.onclose = () => {};

    function proceedToDeviceSelect() {
      const name = document.getElementById('nameInput').value.trim();
      if (name) {
        ws.send(JSON.stringify({ type: 'setName', name }));
        document.getElementById('login').style.display = 'none';
        document.getElementById('deviceSelect').style.display = 'block';
      }
    }

    function selectDevice(type) {
      console.log(`Выбрано устройство: ${type}`); // Логирование для отладки
      deviceType = type;
      const canvasPx = type === 'pc' ? 600 : 450;
      const cellPx = canvasPx / gridSize;
      canvas.width = canvasPx;
      canvas.height = canvasPx;
      document.getElementById('deviceSelect').style.display = 'none';
      document.getElementById('game').style.display = 'block';
      renderInventory();
      needsRedraw = true;
      if (!isGameLoopRunning) { // Запускаем gameLoop только один раз
        isGameLoopRunning = true;
        gameLoop();
      }
    }

    function nearby(x1, y1, x2, y2, range = 1) {
      return Math.abs(x1 - x2) <= range && Math.abs(y1 - y2) <= range && (x1 != x2 || y1 != y2);
    }

    function getCell(x, y) {
      return tiles.get(x + "," + y) || 0;
    }

    function findPath(startX, startY, targetX, targetY) {
      const queue = [{ x: startX, y: startY, path: [] }];
      const visited = new Set([startX + "," + startY]);
      const directions = [
        { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
        { dx: -1, dy: 0 }, { dx: 1, dy: 0 },
        { dx: -1, dy: -1 }, { dx: 1, dy: -1 },
        { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
      ];
      let iterations = 0;
      const maxIterations = 500;
      while (queue.length && iterations++ < maxIterations) {
        const { x, y, path } = queue.shift();
        if (x === targetX && y === targetY) return path.concat({ x, y });
        for (const { dx, dy } of directions) {
          const nextX = x + dx, nextY = y + dy;
          const key = nextX + "," + nextY;
          if (!visited.has(key) && getCell(nextX, nextY) !== 1) {
            visited.add(key);
            queue.push({ x: nextX, y: nextY, path: path.concat({ x, y }) });
          }
        }
      }
      return [];
    }

    function moveAlongPath() {
      const me = players.get(myId);
      if (!me || !path.length) return;
      const now = Date.now();
      if (now - lastMoveTime < moveCooldown) return;
      lastMoveTime = now;
      const nextPos = path.shift();
      if (getCell(nextPos.x, nextPos.y) === 0) {
        if (isRunning && energy >= 4) {
          energy -= 4;
          moveCooldown = 100;
        } else {
          moveCooldown = 250;
        }
        ws.send(JSON.stringify({ type: 'move', x: nextPos.x, y: nextPos.y }));
      } else {
        path = [];
      }
      needsRedraw = true;
    }

    function calculatePath(startX, startY, targetX, targetY) {
      const path = [];
      const dx = targetX - startX, dy = targetY - startY;
      const steps = Math.max(Math.abs(dx), Math.abs(dy));
      if (!steps) return path;
      const xStep = dx / steps, yStep = dy / steps;
      let x = startX, y = startY;
      for (let i = 0; i < steps; i++) {
        x += xStep;
        y += yStep;
        path.push({ x: Math.round(x), y: Math.round(y) });
      }
      return path;
    }

    function updateArrows() {
      const me = players.get(myId);
      if (!me) return;
      const now = Date.now();
      for (let i = arrows.length - 1; i >= 0; i--) {
        const arrow = arrows[i];
        const elapsed = (now - arrow.startTime) / 1000;
        if (elapsed > 10 || !arrow.path.length) {
          arrows.splice(i, 1);
          continue;
        }
        const nextPos = arrow.path.shift();
        arrow.currentX = nextPos.x;
        arrow.currentY = nextPos.y;
        if (tiles.get(arrow.currentX + "," + arrow.currentY) === 1) {
          arrows.splice(i, 1);
          continue;
        }
        for (const [id, player] of players) {
          if (id === arrow.shooterId) continue;
          if (Math.abs(player.x - arrow.currentX) <= 0.5 && Math.abs(player.y - arrow.currentY) <= 0.5) {
            ws.send(JSON.stringify({ type: 'damage', targetId: id, damage: 10 }));
            arrows.splice(i, 1);
            break;
          }
        }
      }
      needsRedraw = true;
    }

    function regenerateEnergy(delta) {
      if (!players.get(myId)) return;
      energy = Math.min(maxEnergy, energy + (path.length ? 4 : 8) / 1000 * delta);
    }

    function updateStats() {
      const me = players.get(myId);
      if (!me) return;
      document.getElementById("stats").innerText = `Здоровье: ${me.hp} | Энергия: ${Math.floor(energy)} | Скорость: ${isRunning ? 'Бег' : 'Обычная'}`;
    }

    function wrapText(text, maxWidth) {
      const words = text.split('');
      const lines = [];
      let currentLine = '';
      for (const char of words) {
        const testLine = currentLine + char;
        if (ctx.measureText(testLine).width > maxWidth && currentLine) {
          lines.push(currentLine);
          currentLine = char;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) lines.push(currentLine);
      return lines;
    }

    function drawGrid(sx, sy) {
      const canvasPx = canvas.width;
      const cellPx = canvasPx / gridSize;
      const cacheKey = `${sx},${sy}`;
      if (!gridCache || gridCache.key !== cacheKey) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = canvasPx;
        offscreenCanvas.height = canvasPx;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        offscreenCtx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        offscreenCtx.lineWidth = 1;
        for (let ty = 0; ty < gridSize; ty++) {
          for (let tx = 0; tx < gridSize; tx++) {
            const wx = sx + tx, wy = sy + ty;
            const xPx = tx * cellPx, yPx = ty * cellPx;
            offscreenCtx.strokeRect(xPx, yPx, cellPx, cellPx);
            if (tiles.get(wx + "," + wy) === 1) {
              offscreenCtx.fillStyle = "rgba(255, 255, 255, 0.9)";
              offscreenCtx.fillRect(xPx + 2, yPx + 2, cellPx - 4, cellPx - 4);
            }
          }
        }
        gridCache = { key: cacheKey, canvas: offscreenCanvas };
      }
      ctx.drawImage(gridCache.canvas, 0, 0);
    }

    function draw() {
      const me = players.get(myId);
      if (!me) return;
      const canvasPx = canvas.width;
      const cellPx = canvasPx / gridSize;
      ctx.clearRect(0, 0, canvasPx, canvasPx);
      const sx = me.x - Math.floor(gridSize / 2);
      const sy = me.y - Math.floor(gridSize / 2);
      drawGrid(sx, sy);

      for (const arrow of arrows) {
        const px1 = (arrow.currentX - sx) * cellPx + cellPx / 2;
        const py1 = (arrow.currentY - sy) * cellPx + cellPx / 2;
        let px2 = px1, py2 = py1;
        if (arrow.path.length) {
          const nextPos = arrow.path[0];
          px2 = (nextPos.x - sx) * cellPx + cellPx / 2;
          py2 = (nextPos.y - sy) * cellPx + cellPx / 2;
        }
        if (px1 >= 0 && px1 <= canvasPx && py1 >= 0 && py1 <= canvasPx) {
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(px1, py1);
          ctx.lineTo(px2, py2);
          ctx.stroke();
        }
      }

      for (const [id, player] of players) {
        const px = (player.x - sx) * cellPx + cellPx / 2;
        const py = (player.y - sy) * cellPx + cellPx / 2;
        if (px < 0 || px > canvasPx || py < 0 || py > canvasPx) continue;
        ctx.fillStyle = player.color;
        ctx.font = "26px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("@", px, py);
        if (player.name) {
          ctx.font = "12px monospace";
          ctx.fillStyle = "white";
          ctx.fillText(player.name, px, py - 20);
          ctx.fillText(`Здоровье: ${player.hp}`, px, py - 35);
        }
      }

      for (const [id, player] of players) {
        const px = (player.x - sx) * cellPx + cellPx / 2;
        const py = (player.y - sy) * cellPx + cellPx / 2;
        if (px < 0 || px > canvasPx || py < 0 || py > canvasPx || !messages.has(id)) continue;
        const playerMessages = messages.get(id);
        const maxWidth = cellPx * 3;
        let totalHeight = 0;
        const lineHeight = 15;
        for (const msg of playerMessages) totalHeight += wrapText(msg.text, maxWidth).length * lineHeight + 10;
        let currentY = py - 50 - totalHeight;
        for (const msg of playerMessages) {
          const lines = wrapText(msg.text, maxWidth);
          const boxHeight = lines.length * lineHeight + 10;
          const boxWidth = maxWidth + 10;
          ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
          ctx.strokeStyle = "white";
          ctx.lineWidth = 1;
          ctx.fillRect(px - boxWidth / 2, currentY, boxWidth, boxHeight);
          ctx.strokeRect(px - boxWidth / 2, currentY, boxWidth, boxHeight);
          ctx.font = "12px monospace";
          ctx.fillStyle = "white";
          ctx.textBaseline = "middle";
          lines.forEach((line, j) => ctx.fillText(line, px, currentY + 5 + (j + 0.5) * lineHeight));
          currentY += boxHeight + 5;
        }
      }

      document.querySelectorAll('.inventory-slot').forEach((slot, index) => {
        const countEl = slot.querySelector('.count');
        if (countEl) countEl.innerText = inventory[index].count || 0;
      });
    }

    let chatUpdatePending = false;
    function updateGlobalChat() {
      if (chatUpdatePending) return;
      chatUpdatePending = true;
      requestAnimationFrame(() => {
        const chatDiv = document.getElementById('globalChat');
        chatDiv.innerText = globalMessages.map(msg => `${msg.name}: ${msg.text}`).join('\n');
        chatDiv.scrollTop = chatDiv.scrollHeight;
        chatUpdatePending = false;
      });
    }

    let playerListUpdatePending = false;
    function updatePlayerList() {
      if (playerListUpdatePending) return;
      playerListUpdatePending = true;
      requestAnimationFrame(() => {
        const playerListDiv = document.getElementById('playerList');
        playerListDiv.innerText = 'Игроки:\n' + Array.from(players.values()).map(player => player.name || 'Без имени').join('\n');
        playerListUpdatePending = false;
      });
    }

    function renderInventory() {
      const inventoryDiv = document.getElementById('inventory');
      inventory.forEach((item, index) => {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.dataset.slot = index;
        slot.innerHTML = `<span>${item.name}</span>` + (item.count !== undefined ? `<span class="count">${item.count}</span>` : '');
        slot.addEventListener('click', () => {
          if (selectedSlot === index) {
            selectedSlot = null;
            slot.classList.remove('selected');
          } else {
            selectedSlot = index;
            document.querySelectorAll('.inventory-slot').forEach(s => s.classList.remove('selected'));
            slot.classList.add('selected');
          }
        });
        inventoryDiv.appendChild(slot);
      });
    }

    function canvasMouseDown(e) {
      const me = players.get(myId);
      if (!me) return;
      const canvasPx = canvas.width;
      const cellPx = canvasPx / gridSize;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const tx = Math.floor(x / cellPx);
      const ty = Math.floor(y / cellPx);
      const targetX = me.x - Math.floor(gridSize / 2) + tx;
      const targetY = me.y - Math.floor(gridSize / 2) + ty;
      if (selectedSlot === null) {
        path = findPath(me.x, me.y, targetX, targetY);
      } else {
        inventory[selectedSlot].action(me, targetX, targetY, ws, nearby, getCell, inventory, players, myId);
      }
    }

    const chatInput = document.getElementById('chatInput');
    document.getElementById('sendChat').addEventListener('click', () => {
      const text = chatInput.value.trim();
      if (text) {
        ws.send(JSON.stringify({ type: 'chat', text }));
        chatInput.value = '';
      }
    });

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const text = chatInput.value.trim();
        if (text) {
          ws.send(JSON.stringify({ type: 'chat', text }));
          chatInput.value = '';
        }
      }
    });

    const runButton = document.getElementById('runButton');
    runButton.addEventListener('click', () => {
      isRunning = !isRunning;
      runButton.innerText = isRunning ? 'Ходьба' : 'Бег';
      moveCooldown = isRunning ? 100 : 250;
    });

    document.addEventListener('keydown', (e) => {
      const activeElement = document.activeElement;
      if (activeElement.tagName === 'INPUT' && (activeElement.id === 'nameInput' || activeElement.id === 'chatInput')) return;
      if (e.key === 'q' || e.key === 'Q') {
        chatInput.focus();
      }
      if (['1', '2', '3', '4', '5'].includes(e.key)) {
        e.preventDefault();
        const index = parseInt(e.key) - 1;
        if (selectedSlot === index) {
          selectedSlot = null;
          document.querySelector(`.inventory-slot[data-slot="${index}"]`).classList.remove('selected');
        } else {
          selectedSlot = index;
          document.querySelectorAll('.inventory-slot').forEach(slot => slot.classList.remove('selected'));
          document.querySelector(`.inventory-slot[data-slot="${index}"]`).classList.add('selected');
        }
      }
    });

    canvas.onmousedown = canvasMouseDown;
    canvas.ontouchstart = (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      canvas.dispatchEvent(new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
      }));
    };

    function gameLoop(timestamp) {
      if (!lastUpdateTime) lastUpdateTime = timestamp;
      const delta = timestamp - lastUpdateTime;
      lastUpdateTime = timestamp;

      moveAlongPath();
      updateArrows();
      regenerateEnergy(delta);
      updateStats();
      if (needsRedraw) {
        draw();
        needsRedraw = false;
      }
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
  </html>
