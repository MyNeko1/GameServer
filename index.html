<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background: #000;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      position: relative;
      font-family: monospace;
    }
    canvas {
      border: 1px solid white;
      touch-action: none;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    .inv {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px;
      border: 1px solid white;
      border-radius: 5px;
    }
    #login, #deviceSelect {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      padding: 20px;
      border: 1px solid white;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      text-align: center;
    }
    #deviceSelect {
      display: none;
    }
    #game {
      display: none;
    }
    .chat {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    #chatInput {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 5px;
      font-size: 14px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      width: 200px;
    }
    #sendChat {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 5px 10px;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    }
    .global-chat {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 200px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid white;
      border-radius: 5px;
      padding: 5px;
      overflow-y: auto;
      font-size: 12px;
    }
    .global-chat-message {
      margin-bottom: 5px;
      word-wrap: break-word;
    }
    .player-list {
      position: absolute;
      top: 220px;
      right: 10px;
      width: 200px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid white;
      border-radius: 5px;
      padding: 5px;
      font-size: 12px;
    }
    .player-list-item {
      margin-bottom: 3px;
    }
    .inventory {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    .inventory-slot {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      border-radius: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      text-align: center;
      cursor: pointer;
      position: relative;
    }
    .inventory-slot.selected {
      border-color: yellow;
      background: rgba(255, 255, 255, 0.4);
    }
    .inventory-slot .count {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 2px;
      border-radius: 3px;
    }
    @media (max-width: 600px), (orientation: landscape) {
      #chatInput {
        width: 150px;
        font-size: 12px;
      }
      #sendChat {
        padding: 5px;
        font-size: 12px;
      }
      .inventory-slot {
        width: 40px;
        height: 40px;
        font-size: 10px;
      }
      .inventory-slot .count {
        font-size: 8px;
      }
      .chat {
        bottom: 70px;
      }
      .inventory {
        bottom: 10px;
      }
      .global-chat {
        width: 150px;
        height: 150px;
        font-size: 10px;
      }
      .player-list {
        width: 150px;
        font-size: 10px;
        top: 170px;
      }
    }
    @media (min-width: 601px) {
      .chat {
        bottom: 100px;
      }
      .inventory {
        bottom: 40px;
      }
    }
  </style>
</head>
<body>
  <div id="login">
    <input type="text" id="nameInput" placeholder="как звать путник?" maxlength="10">
    <button onclick="proceedToDeviceSelect()">играть</button>
  </div>
  <div id="deviceSelect">
    <p>Ты с чем сидишь?</p>
    <button onclick="selectDevice('pc')">ПК</button>
    <button onclick="selectDevice('mobile')">Мобила</button>
  </div>
  <div id="game">
    <canvas id="gameCanvas"></canvas>
    <div class="inv" id="invCount">HP: 100</div>
    <div class="chat">
      <input type="text" id="chatInput" placeholder="начать базарить" maxlength="50">
      <button id="sendChat">ГАФ</button>
    </div>
    <div class="global-chat" id="globalChat"></div>
    <div class="player-list" id="playerList"></div>
    <div class="inventory" id="inventory"></div>
  </div>
  <script src="/items.js"></script>
  <script>
    let gridSize = 15, cellPx = 30, canvasPx = gridSize * cellPx;
    let deviceType = null;
    let canvas = document.getElementById("gameCanvas");
    let ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    let tiles = new Map();
    let players = new Map();
    let messages = new Map();
    let globalMessages = [];
    let arrows = [];
    const maxArrows = 50;
    let myId = null;
    let selectedSlot = null;
    let inventory = getItems();
    let path = [];
    let needsRedraw = false;
    let gridCache = null;
    const ws = new WebSocket('wss://' + window.location.hostname);
    ws.onopen = () => {
      console.log('Connected to server');
    };
    ws.onmessage = (message) => {
      const data = JSON.parse(message.data);
      if (data.type === 'init') {
        myId = data.id;
        players = new Map(Object.entries(data.players));
        tiles = new Map(Object.entries(data.tiles));
        inventory[0].count = players.get(myId).blocks || 0;
        updatePlayerList();
        needsRedraw = true;
      } else if (data.type === 'batch') {
        data.updates.forEach((update) => {
          if (update.type === 'join') {
            players.set(update.id, update.player);
            updatePlayerList();
          } else if (update.type === 'updatePlayer') {
            players.set(update.id, update.player);
            if (update.id === myId) {
              inventory[0].count = update.player.blocks || 0;
            }
          } else if (update.type === 'updateTile') {
            tiles.set(update.x + "," + update.y, update.value);
            gridCache = null;
          } else if (update.type === 'leave') {
            players.delete(update.id);
            messages.delete(update.id);
            updatePlayerList();
          } else if (update.type === 'chat') {
            const { id, text, timestamp } = update;
            const player = players.get(id);
            if (player) {
              globalMessages.push({ id, name: player.name, text, timestamp });
              updateGlobalChat();
              setTimeout(() => {
                globalMessages = globalMessages.filter(m => m.timestamp !== timestamp);
                updateGlobalChat();
              }, 60000);
            }
            if (!messages.has(id)) messages.set(id, []);
            messages.get(id).push({ text, timestamp });
            setTimeout(() => {
              const playerMessages = messages.get(id);
              if (playerMessages) {
                const index = playerMessages.findIndex(m => m.timestamp === timestamp);
                if (index !== -1) playerMessages.splice(index, 1);
                if (playerMessages.length === 0) messages.delete(id);
              }
            }, 10000);
          } else if (update.type === 'arrow') {
            if (arrows.length < maxArrows) {
              arrows.push({
                x: update.x,
                y: update.y,
                targetX: update.targetX,
                targetY: update.targetY,
                startTime: Date.now(),
                shooterId: update.shooterId,
                currentX: update.x,
                currentY: update.y,
                path: calculatePath(update.x, update.y, update.targetX, update.targetY)
              });
            }
          }
        });
        needsRedraw = true;
      }
    };
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    ws.onclose = () => {
      console.log('WebSocket connection closed');
    };
    function proceedToDeviceSelect() {
      const name = document.getElementById('nameInput').value.trim();
      if (name) {
        ws.send(JSON.stringify({ type: 'setName', name }));
        document.getElementById('login').style.display = 'none';
        document.getElementById('deviceSelect').style.display = 'block';
      }
    }
    function selectDevice(type) {
      deviceType = type;
      if (type === 'pc') {
        canvasPx = 600;
        cellPx = canvasPx / gridSize;
      } else {
        canvasPx = 450;
        cellPx = canvasPx / gridSize;
      }
      canvas.width = canvasPx;
      canvas.height = canvasPx;
      document.getElementById('deviceSelect').style.display = 'none';
      document.getElementById('game').style.display = 'block';
      renderInventory();
      needsRedraw = true;
    }
    function nearby(x1, y1, x2, y2, range = 1) {
      return Math.abs(x1 - x2) <= range && Math.abs(y1 - y2) <= range && (x1 != x2 || y1 != y2);
    }
    function getCell(x, y) {
      return tiles.get(x + "," + y);
    }
    function findPath(startX, startY, targetX, targetY) {
      let queue = [{ x: startX, y: startY, path: [], cost: 0 }];
      let visited = new Set();
      visited.add(startX + "," + startY);
      const directions = [
        { dx: 0, dy: -1, cost: 10 },
        { dx: 0, dy: 1, cost: 10 },
        { dx: -1, dy: 0, cost: 10 },
        { dx: 1, dy: 0, cost: 10 },
        { dx: -1, dy: -1, cost: 14 },
        { dx: 1, dy: -1, cost: 14 },
        { dx: -1, dy: 1, cost: 14 },
        { dx: 1, dy: 1, cost: 14 }
      ];
      let iterations = 0;
      const maxIterations = 1000;
      while (queue.length > 0 && iterations < maxIterations) {
        iterations++;
        let { x, y, path } = queue.shift();
        if (x === targetX && y === targetY) {
          return path.concat({ x, y });
        }
        for (let dir of directions) {
          let nextX = x + dir.dx;
          let nextY = y + dir.dy;
          let key = nextX + "," + nextY;
          if (!visited.has(key) && getCell(nextX, nextY) !== 1) {
            visited.add(key);
            queue.push({ x: nextX, y: nextY, path: path.concat({ x, y }) });
          }
        }
        queue.sort((a, b) => a.cost - b.cost);
      }
      return [];
    }
    function moveAlongPath() {
      const me = players.get(myId);
      if (!me || path.length === 0) return;
      let nextPos = path.shift();
      if (getCell(nextPos.x, nextPos.y) === 0) {
        ws.send(JSON.stringify({ type: 'move', x: nextPos.x, y: nextPos.y }));
      } else {
        path = [];
      }
      needsRedraw = true;
    }
    setInterval(() => {
      moveAlongPath();
      updateArrows();
      if (needsRedraw) {
        draw();
        needsRedraw = false;
      }
    }, 200);
    function calculatePath(startX, startY, targetX, targetY) {
      let path = [];
      let dx = targetX - startX;
      let dy = targetY - startY;
      let steps = Math.max(Math.abs(dx), Math.abs(dy));
      if (steps === 0) return path;
      let xStep = dx / steps;
      let yStep = dy / steps;
      let x = startX;
      let y = startY;
      for (let i = 0; i < steps; i++) {
        x += xStep;
        y += yStep;
        path.push({ x: Math.round(x), y: Math.round(y) });
      }
      return path;
    }
    function updateArrows() {
      const me = players.get(myId);
      if (!me) return;
      let sx = me.x - Math.floor(gridSize / 2);
      let sy = me.y - Math.floor(gridSize / 2);
      arrows = arrows.filter(arrow => {
        const elapsed = (Date.now() - arrow.startTime) / 1000;
        if (elapsed > 10) return false;
        if (arrow.path.length === 0) return false;
        let nextPos = arrow.path.shift();
        arrow.currentX = nextPos.x;
        arrow.currentY = nextPos.y;
        if (tiles.get(arrow.currentX + "," + arrow.currentY) == 1) return false;
        for (let [id, player] of players) {
          if (id === arrow.shooterId) continue;
          if (Math.abs(player.x - arrow.currentX) <= 0.5 && Math.abs(player.y - arrow.currentY) <= 0.5) {
            ws.send(JSON.stringify({ type: 'damage', targetId: id, damage: 10 }));
            return false;
          }
        }
        return true;
      });
      needsRedraw = true;
    }
    function wrapText(text, maxWidth) {
      const words = text.split('');
      let lines = [];
      let currentLine = '';
      for (let i = 0; i < words.length; i++) {
        const testLine = currentLine + words[i];
        const testWidth = ctx.measureText(testLine).width;
        if (testWidth > maxWidth && currentLine !== '') {
          lines.push(currentLine);
          currentLine = words[i];
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) lines.push(currentLine);
      return lines;
    }
    function drawGrid(sx, sy) {
      const cacheKey = `${sx},${sy}`;
      if (!gridCache || gridCache.key !== cacheKey) {
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = canvasPx;
        offscreenCanvas.height = canvasPx;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        for (let ty = 0; ty < gridSize; ty++) {
          for (let tx = 0; tx < gridSize; tx++) {
            let wx = sx + tx, wy = sy + ty;
            let xPx = tx * cellPx, yPx = ty * cellPx;
            offscreenCtx.strokeStyle = "rgba(255, 255, 255, 0.3)";
            offscreenCtx.lineWidth = 1;
            offscreenCtx.strokeRect(xPx, yPx, cellPx, cellPx);
            if (tiles.get(wx + "," + wy) == 1) {
              offscreenCtx.fillStyle = "rgba(255, 255, 255, 0.9)";
              offscreenCtx.fillRect(xPx + 2, yPx + 2, cellPx - 4, cellPx - 4);
              offscreenCtx.shadowColor = "rgba(255, 255, 255, 0.3)";
              offscreenCtx.shadowBlur = 5;
              offscreenCtx.fillRect(xPx + 2, yPx + 2, cellPx - 4, cellPx - 4);
              offscreenCtx.shadowBlur = 0;
            }
          }
        }
        gridCache = { key: cacheKey, canvas: offscreenCanvas };
      }
      ctx.drawImage(gridCache.canvas, 0, 0);
    }
    function draw() {
      ctx.clearRect(0, 0, canvasPx, canvasPx);
      const me = players.get(myId);
      if (!me) return;
      let sx = me.x - Math.floor(gridSize / 2);
      let sy = me.y - Math.floor(gridSize / 2);
      drawGrid(sx, sy);
      for (let arrow of arrows) {
        let px1 = (arrow.currentX - sx) * cellPx + cellPx / 2;
        let py1 = (arrow.currentY - sy) * cellPx + cellPx / 2;
        let px2 = px1;
        let py2 = py1;
        if (arrow.path.length > 0) {
          let nextPos = arrow.path[0];
          px2 = (nextPos.x - sx) * cellPx + cellPx / 2;
          py2 = (nextPos.y - sy) * cellPx + cellPx / 2;
        }
        if (px1 >= 0 && px1 <= canvasPx && py1 >= 0 && py1 <= canvasPx) {
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(px1, py1);
          ctx.lineTo(px2, py2);
          ctx.stroke();
        }
      }
      for (let [id, player] of players) {
        let px = (player.x - sx) * cellPx + cellPx / 2;
        let py = (player.y - sy) * cellPx + cellPx / 2;
        if (px >= 0 && px <= canvasPx && py >= 0 && py <= canvasPx) {
          ctx.fillStyle = player.color;
          ctx.font = "26px monospace";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
          ctx.shadowBlur = 3;
          ctx.fillText("@", px, py);
          ctx.shadowBlur = 0;
          if (player.name) {
            ctx.font = "12px monospace";
            ctx.fillStyle = "white";
            ctx.fillText(player.name, px, py - 20);
            ctx.fillText(`HP: ${player.hp}`, px, py - 35);
          }
        }
      }
      for (let [id, player] of players) {
        let px = (player.x - sx) * cellPx + cellPx / 2;
        let py = (player.y - sy) * cellPx + cellPx / 2;
        if (px >= 0 && px <= canvasPx && py >= 0 && py <= canvasPx) {
          if (messages.has(id)) {
            const playerMessages = messages.get(id);
            const maxWidth = cellPx * 3;
            let totalHeight = 0;
            const lineHeight = 15;
            for (let i = 0; i < playerMessages.length; i++) {
              const lines = wrapText(playerMessages[i].text, maxWidth);
              totalHeight += lines.length * lineHeight + 10;
            }
            let currentY = py - 50 - totalHeight;
            for (let i = 0; i < playerMessages.length; i++) {
              const lines = wrapText(playerMessages[i].text, maxWidth);
              const boxHeight = lines.length * lineHeight + 10;
              const boxWidth = maxWidth + 10;
              ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
              ctx.strokeStyle = "white";
              ctx.lineWidth = 1;
              ctx.fillRect(px - boxWidth / 2, currentY, boxWidth, boxHeight);
              ctx.strokeRect(px - boxWidth / 2, currentY, boxWidth, boxHeight);
              ctx.font = "12px monospace";
              ctx.fillStyle = "white";
              ctx.textBaseline = "middle";
              for (let j = 0; j < lines.length; j++) {
                ctx.fillText(lines[j], px, currentY + 5 + (j + 0.5) * lineHeight);
              }
              currentY += boxHeight + 5;
            }
          }
        }
      }
      document.getElementById("invCount").textContent = `HP: ${me.hp}`;
      document.querySelectorAll('.inventory-slot').forEach((slot, index) => {
        const countEl = slot.querySelector('.count');
        if (countEl) {
          countEl.textContent = inventory[index].count || 0;
        }
      });
    }
    let chatUpdatePending = false;
    function updateGlobalChat() {
      if (chatUpdatePending) return;
      chatUpdatePending = true;
      requestAnimationFrame(() => {
        const chatDiv = document.getElementById('globalChat');
        chatDiv.innerHTML = '';
        globalMessages.forEach(msg => {
          const msgDiv = document.createElement('div');
          msgDiv.className = 'global-chat-message';
          msgDiv.textContent = `${msg.name}: ${msg.text}`;
          chatDiv.appendChild(msgDiv);
        });
        chatDiv.scrollTop = chatDiv.scrollHeight;
        chatUpdatePending = false;
      });
    }
    let playerListUpdatePending = false;
    function updatePlayerList() {
      if (playerListUpdatePending) return;
      playerListUpdatePending = true;
      requestAnimationFrame(() => {
        const playerListDiv = document.getElementById('playerList');
        playerListDiv.innerHTML = '<strong>Игроки:</strong>';
        players.forEach((player, id) => {
          const playerDiv = document.createElement('div');
          playerDiv.className = 'player-list-item';
          playerDiv.textContent = player.name || 'ноу нейм';
          playerListDiv.appendChild(playerDiv);
        });
        playerListUpdatePending = false;
      });
    }
    function renderInventory() {
      const inventoryDiv = document.getElementById('inventory');
      inventoryDiv.innerHTML = '';
      inventory.forEach((item, index) => {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.setAttribute('data-slot', index);
        slot.innerHTML = `<span>${item.name}</span>` + (item.count !== undefined ? `<span class="count">${item.count}</span>` : '');
        inventoryDiv.appendChild(slot);
        slot.addEventListener('click', () => {
          selectedSlot = parseInt(slot.getAttribute('data-slot'));
          document.querySelectorAll('.inventory-slot').forEach(s => s.classList.remove('selected'));
          slot.classList.add('selected');
        });
      });
    }
    function canvasMouseDown(e) {
      const me = players.get(myId);
      if (!me) return;
      let rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      let tx = Math.floor(x / cellPx);
      let ty = Math.floor(y / cellPx);
      let targetX = me.x - Math.floor(gridSize / 2) + tx;
      let targetY = me.y - Math.floor(gridSize / 2) + ty;
      if (selectedSlot === null) {
        path = findPath(me.x, me.y, targetX, targetY);
      } else {
        const item = inventory[selectedSlot];
        item.action(me, targetX, targetY, ws, nearby, getCell, inventory, players, myId);
      }
    }
    document.getElementById('sendChat').addEventListener('click', () => {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (text) {
        ws.send(JSON.stringify({ type: 'chat', text }));
        input.value = '';
      }
    });
    document.getElementById('chatInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const input = document.getElementById('chatInput');
        const text = input.value.trim();
        if (text) {
          ws.send(JSON.stringify({ type: 'chat', text }));
          input.value = '';
        }
      }
    });
    document.addEventListener('keydown', (e) => {
      const activeElement = document.activeElement;
      const isInputFocused = activeElement.tagName === 'INPUT' && (activeElement.id === 'nameInput' || activeElement.id === 'chatInput');
      if (!isInputFocused) {
        if (e.key === 'q' || e.key === 'Q') {
          document.getElementById('chatInput').focus();
        }
        if (['1', '2', '3', '4', '5'].includes(e.key)) {
          e.preventDefault();
          selectedSlot = parseInt(e.key) - 1;
          document.querySelectorAll('.inventory-slot').forEach(slot => slot.classList.remove('selected'));
          document.querySelector(`.inventory-slot[data-slot="${selectedSlot}"]`).classList.add('selected');
        }
      }
    });
    canvas.onmousedown = canvasMouseDown;
    canvas.ontouchstart = (e) => {
      e.preventDefault();
      let touch = e.touches[0];
      let mouseDown = new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseDown);
    };
  </script>
</body>
</html>
