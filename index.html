<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background: #000;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      position: relative;
      font-family: monospace;
    }
    canvas {
      border: 1px solid white;
      touch-action: none;
    }
    .buttons {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .btn {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 14px;
      user-select: none;
      touch-action: manipulation;
    }
    .btn.active {
      background: #666;
    }
    .inv {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
    }
    #login {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      padding: 20px;
      border: 1px solid white;
    }
    #game {
      display: none;
    }
    .chat {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    #chatInput {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 5px;
      font-size: 14px;
    }
    #sendChat {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 5px 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="login">
    <input type="text" id="nameInput" placeholder="ты гей?" maxlength="10">
    <button onclick="joinGame()">да</button>
  </div>
  <div id="game">
    <canvas id="gameCanvas"></canvas>
    <div class="inv" id="invCount">Блоки: 0</div>
    <div class="buttons">
      <button class="btn active" id="moveMode">Движение</button>
      <button class="btn" id="buildMode">Строительство</button>
      <button class="btn" id="breakMode">Ломание</button>
    </div>
    <div class="chat">
      <input type="text" id="chatInput" placeholder="начать базарить" maxlength="50">
      <button id="sendChat">ГАФ</button>
    </div>
  </div>
  <script>
    let gridSize = 15, cellPx = 30, canvasPx = gridSize * cellPx;
    let canvas = document.getElementById("gameCanvas");
    canvas.width = canvasPx;
    canvas.height = canvasPx;
    let ctx = canvas.getContext("2d");
    let tiles = new Map();
    let players = new Map();
    let messages = new Map();
    let myId = null;
    let mode = "move";
    const ws = new WebSocket('wss://' + window.location.hostname);
    ws.onopen = () => {
      console.log('Connected to server');
    };
    ws.onmessage = (message) => {
      const data = JSON.parse(message.data);
      if (data.type === 'init') {
        myId = data.id;
        players = new Map(Object.entries(data.players));
        tiles = new Map(Object.entries(data.tiles));
        draw();
      } else if (data.type === 'batch') {
        data.updates.forEach((update) => {
          if (update.type === 'join') {
            players.set(update.id, update.player);
          } else if (update.type === 'updatePlayer') {
            players.set(update.id, update.player);
          } else if (update.type === 'updateTile') {
            tiles.set(update.x + "," + update.y, update.value);
          } else if (update.type === 'leave') {
            players.delete(update.id);
            messages.delete(update.id);
          } else if (update.type === 'chat') {
            const { id, text, timestamp } = update;
            if (!messages.has(id)) messages.set(id, []);
            messages.get(id).push({ text, timestamp });
            setTimeout(() => {
              const playerMessages = messages.get(id);
              if (playerMessages) {
                const index = playerMessages.findIndex(m => m.timestamp === timestamp);
                if (index !== -1) playerMessages.splice(index, 1);
                if (playerMessages.length === 0) messages.delete(id);
              }
            }, 10000);
          }
        });
        draw();
      }
    };
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    ws.onclose = () => {
      console.log('WebSocket connection closed');
    };
    function joinGame() {
      const name = document.getElementById('nameInput').value.trim();
      if (name) {
        ws.send(JSON.stringify({ type: 'setName', name }));
        document.getElementById('login').style.display = 'none';
        document.getElementById('game').style.display = 'block';
      }
    }
    function nearby(x1, y1, x2, y2) {
      return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && (x1 != x2 || y1 != y2);
    }
    function draw() {
      ctx.clearRect(0, 0, canvasPx, canvasPx);
      const me = players.get(myId);
      if (!me) return;
      let sx = me.x - Math.floor(gridSize / 2);
      let sy = me.y - Math.floor(gridSize / 2);
      for (let ty = 0; ty < gridSize; ty++) {
        for (let tx = 0; tx < gridSize; tx++) {
          let wx = sx + tx, wy = sy + ty;
          let xPx = tx * cellPx, yPx = ty * cellPx;
          ctx.strokeStyle = "white";
          ctx.strokeRect(xPx, yPx, cellPx, cellPx);
          if (tiles.get(wx + "," + wy) == 1) {
            ctx.fillStyle = "white";
            ctx.fillRect(xPx, yPx, cellPx, cellPx);
          } else if (nearby(me.x, me.y, wx, wy)) {
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(xPx + cellPx / 2, yPx + cellPx / 2, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      for (let [id, player] of players) {
        let px = (player.x - sx) * cellPx + cellPx / 2;
        let py = (player.y - sy) * cellPx + cellPx / 2;
        if (px >= 0 && px <= canvasPx && py >= 0 && py <= canvasPx) {
          ctx.fillStyle = player.color;
          ctx.font = "26px monospace";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("@", px, py);
          if (player.name) {
            ctx.font = "12px monospace";
            ctx.fillText(player.name, px, py - 20);
          }
        }
      }
      for (let [id, player] of players) {
        let px = (player.x - sx) * cellPx + cellPx / 2;
        let py = (player.y - sy) * cellPx + cellPx / 2;
        if (px >= 0 && px <= canvasPx && py >= 0 && py <= canvasPx) {
          if (messages.has(id)) {
            const playerMessages = messages.get(id);
            for (let i = 0; i < playerMessages.length; i++) {
              ctx.font = "12px monospace";
              ctx.fillStyle = "white";
              ctx.fillText(playerMessages[i].text, px, py - 35 - i * 15);
            }
          }
        }
      }
      document.getElementById("invCount").textContent = "Клетки: " + me.blocks;
    }
    function canvasClick(e) {
      const me = players.get(myId);
      if (!me) return;
      let rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      let tx = Math.floor(x / cellPx);
      let ty = Math.floor(y / cellPx);
      let targetX = me.x - Math.floor(gridSize / 2) + tx;
      let targetY = me.y - Math.floor(gridSize / 2) + ty;
      if (nearby(me.x, me.y, targetX, targetY)) {
        if (mode == "move") {
          ws.send(JSON.stringify({ type: 'move', x: targetX, y: targetY }));
        } else if (mode == "break") {
          ws.send(JSON.stringify({ type: 'break', x: targetX, y: targetY }));
        } else if (mode == "build") {
          ws.send(JSON.stringify({ type: 'build', x: targetX, y: targetY }));
        }
      }
    }
    let btns = {
      move: document.getElementById("moveMode"),
      build: document.getElementById("buildMode"),
      break: document.getElementById("breakMode")
    };
    function switchMode(newMode) {
      mode = newMode;
      for (let key in btns) {
        btns[key].classList.toggle("active", key == newMode);
      }
    }
    btns.move.onclick = () => switchMode("move");
    btns.build.onclick = () => switchMode("build");
    btns.break.onclick = () => switchMode("break");
    document.getElementById('sendChat').addEventListener('click', () => {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (text) {
        ws.send(JSON.stringify({ type: 'chat', text }));
        input.value = '';
      }
    });
    canvas.onclick = canvasClick;
    canvas.ontouchstart = (e) => {
      e.preventDefault();
      let touch = e.touches[0];
      let click = new MouseEvent("click", {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(click);
    };
  </script>
</body>
</html>
