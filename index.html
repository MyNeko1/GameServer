<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background: #000;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      overflow: hidden;
      position: relative;
      font-family: monospace;
    }
    canvas {
      border: 1px solid white;
      touch-action: none;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    .inv {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px;
      border: 1px solid white;
      border-radius: 5px;
    }
    #login {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #333;
      padding: 20px;
      border: 1px solid white;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    #game {
      display: none;
    }
    .chat {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    #chatInput {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 5px;
      font-size: 14px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      width: 200px;
    }
    #sendChat {
      background: #333;
      color: white;
      border: 1px solid white;
      padding: 5px 10px;
      cursor: pointer;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    }
    .dpad {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: none;
      grid-template-columns: repeat(3, 40px);
      grid-template-rows: repeat(3, 40px);
      gap: 5px;
    }
    .dpad-button {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid white;
      border-radius: 5px;
      color: white;
      font-size: 16px;
      text-align: center;
      line-height: 40px;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }
    .dpad-button:active {
      background: rgba(255, 255, 255, 0.5);
    }
    .inventory {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
    }
    .inventory-slot {
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      border-radius: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 12px;
      text-align: center;
      cursor: pointer;
      position: relative;
    }
    .inventory-slot.selected {
      border-color: yellow;
      background: rgba(255, 255, 255, 0.4);
    }
    .inventory-slot .count {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 2px;
      border-radius: 3px;
    }
    @media (max-width: 600px) {
      .dpad {
        display: grid;
      }
      #chatInput {
        width: 150px;
        font-size: 12px;
      }
      #sendChat {
        padding: 5px;
        font-size: 12px;
      }
      .inventory-slot {
        width: 40px;
        height: 40px;
        font-size: 10px;
      }
      .inventory-slot .count {
        font-size: 8px;
      }
    }
  </style>
</head>
<body>
  <div id="login">
    <input type="text" id="nameInput" placeholder="сюда впиши имя" maxlength="10">
    <button onclick="joinGame()">играть</button>
  </div>
  <div id="game">
    <canvas id="gameCanvas"></canvas>
    <div class="inv" id="invCount">HP: 100</div>
    <div class="chat">
      <input type="text" id="chatInput" placeholder="начать базарить" maxlength="50">
      <button id="sendChat">ГАФ</button>
    </div>
    <div class="dpad" id="dpad">
      <div class="dpad-button" data-dir="nw">↖</div>
      <div class="dpad-button" data-dir="n">↑</div>
      <div class="dpad-button" data-dir="ne">↗</div>
      <div class="dpad-button" data-dir="w">←</div>
      <div class="dpad-button"></div>
      <div class="dpad-button" data-dir="e">→</div>
      <div class="dpad-button" data-dir="sw">↙</div>
      <div class="dpad-button" data-dir="s">↓</div>
      <div class="dpad-button" data-dir="se">↘</div>
    </div>
    <div class="inventory" id="inventory">
      <div class="inventory-slot" data-slot="0"><span>Блоки</span><span class="count">0</span></div>
      <div class="inventory-slot" data-slot="1">Меч</div>
      <div class="inventory-slot" data-slot="2">Кирка</div>
      <div class="inventory-slot" data-slot="3">Лук</div>
      <div class="inventory-slot" data-slot="4">Еда</div>
    </div>
  </div>
  <script>
    let gridSize = 15, cellPx = 30, canvasPx = gridSize * cellPx;
    let canvas = document.getElementById("gameCanvas");
    canvas.width = canvasPx;
    canvas.height = canvasPx;
    let ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    let tiles = new Map();
    let players = new Map();
    let messages = new Map();
    let arrows = [];
    let myId = null;
    let keysPressed = new Set();
    let selectedSlot = null;
    let inventory = [
      { type: "blocks", count: 0 },
      { type: "sword" },
      { type: "pickaxe" },
      { type: "bow" },
      { type: "food" }
    ];
    const ws = new WebSocket('wss://' + window.location.hostname);
    ws.onopen = () => {
      console.log('Connected to server');
    };
    ws.onmessage = (message) => {
      const data = JSON.parse(message.data);
      if (data.type === 'init') {
        myId = data.id;
        players = new Map(Object.entries(data.players));
        tiles = new Map(Object.entries(data.tiles));
        inventory[0].count = players.get(myId).blocks || 0;
        draw();
      } else if (data.type === 'batch') {
        data.updates.forEach((update) => {
          if (update.type === 'join') {
            players.set(update.id, update.player);
          } else if (update.type === 'updatePlayer') {
            players.set(update.id, update.player);
            if (update.id === myId) {
              inventory[0].count = update.player.blocks || 0;
            }
          } else if (update.type === 'updateTile') {
            tiles.set(update.x + "," + update.y, update.value);
          } else if (update.type === 'leave') {
            players.delete(update.id);
            messages.delete(update.id);
          } else if (update.type === 'chat') {
            const { id, text, timestamp } = update;
            if (!messages.has(id)) messages.set(id, []);
            messages.get(id).push({ text, timestamp });
            setTimeout(() => {
              const playerMessages = messages.get(id);
              if (playerMessages) {
                const index = playerMessages.findIndex(m => m.timestamp === timestamp);
                if (index !== -1) playerMessages.splice(index, 1);
                if (playerMessages.length === 0) messages.delete(id);
              }
            }, 10000);
          } else if (update.type === 'arrow') {
            arrows.push({ x: update.x, y: update.y, targetX: update.targetX, targetY: update.targetY });
          }
        });
        draw();
      }
    };
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    ws.onclose = () => {
      console.log('WebSocket connection closed');
    };
    function joinGame() {
      const name = document.getElementById('nameInput').value.trim();
      if (name) {
        ws.send(JSON.stringify({ type: 'setName', name }));
        document.getElementById('login').style.display = 'none';
        document.getElementById('game').style.display = 'block';
      }
    }
    function nearby(x1, y1, x2, y2, range = 1) {
      return Math.abs(x1 - x2) <= range && Math.abs(y1 - y2) <= range && (x1 != x2 || y1 != y2);
    }
    function moveWithKeys() {
      const me = players.get(myId);
      if (!me) return;
      let nextX = me.x;
      let nextY = me.y;
      if (keysPressed.has('w') || keysPressed.has('W')) nextY--;
      if (keysPressed.has('s') || keysPressed.has('S')) nextY++;
      if (keysPressed.has('a') || keysPressed.has('A')) nextX--;
      if (keysPressed.has('d') || keysPressed.has('D')) nextX++;
      if (nextX !== me.x || nextY !== me.y) {
        if (nearby(me.x, me.y, nextX, nextY, 1) && getCell(nextX, nextY) === 0) {
          ws.send(JSON.stringify({ type: 'move', x: nextX, y: nextY }));
        }
      }
    }
    function moveWithDpad(dir) {
      const me = players.get(myId);
      if (!me) return;
      let nextX = me.x;
      let nextY = me.y;
      if (dir === 'n') nextY--;
      if (dir === 's') nextY++;
      if (dir === 'w') nextX--;
      if (dir === 'e') nextX++;
      if (dir === 'nw') { nextX--; nextY--; }
      if (dir === 'ne') { nextX++; nextY--; }
      if (dir === 'sw') { nextX--; nextY++; }
      if (dir === 'se') { nextX++; nextY++; }
      if (nextX !== me.x || nextY !== me.y) {
        if (nearby(me.x, me.y, nextX, nextY, 1) && getCell(nextX, nextY) === 0) {
          ws.send(JSON.stringify({ type: 'move', x: nextX, y: nextY }));
        }
      }
    }
    setInterval(() => {
      if (keysPressed.size > 0) moveWithKeys();
      updateArrows();
    }, 100);
    function updateArrows() {
      const me = players.get(myId);
      if (!me) return;
      let sx = me.x - Math.floor(gridSize / 2);
      let sy = me.y - Math.floor(gridSize / 2);
      arrows = arrows.filter(arrow => {
        const dx = arrow.targetX - arrow.x;
        const dy = arrow.targetY - arrow.y;
        if (Math.abs(dx) <= 0.1 && Math.abs(dy) <= 0.1) {
          return false;
        }
        arrow.x += dx * 0.2;
        arrow.y += dy * 0.2;
        const wx = Math.round(arrow.x);
        const wy = Math.round(arrow.y);
        if (tiles.get(wx + "," + wy) == 1) {
          return false;
        }
        for (let [id, player] of players) {
          if (Math.abs(player.x - wx) <= 0.5 && Math.abs(player.y - wy) <= 0.5) {
            ws.send(JSON.stringify({ type: 'damage', targetId: id, damage: 10 }));
            return false;
          }
        }
        return true;
      });
      draw();
    }
    function wrapText(text, maxWidth) {
      const words = text.split('');
      let lines = [];
      let currentLine = '';
      for (let i = 0; i < words.length; i++) {
        const testLine = currentLine + words[i];
        const testWidth = ctx.measureText(testLine).width;
        if (testWidth > maxWidth && currentLine !== '') {
          lines.push(currentLine);
          currentLine = words[i];
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) lines.push(currentLine);
      return lines;
    }
    function draw() {
      ctx.clearRect(0, 0, canvasPx, canvasPx);
      const me = players.get(myId);
      if (!me) return;
      let sx = me.x - Math.floor(gridSize / 2);
      let sy = me.y - Math.floor(gridSize / 2);
      for (let ty = 0; ty < gridSize; ty++) {
        for (let tx = 0; tx < gridSize; tx++) {
          let wx = sx + tx, wy = sy + ty;
          let xPx = tx * cellPx, yPx = ty * cellPx;
          ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
          ctx.lineWidth = 0.3;
          ctx.strokeRect(xPx, yPx, cellPx, cellPx);
          if (tiles.get(wx + "," + wy) == 1) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.fillRect(xPx + 2, yPx + 2, cellPx - 4, cellPx - 4);
            ctx.shadowColor = "rgba(255, 255, 255, 0.3)";
            ctx.shadowBlur = 5;
            ctx.fillRect(xPx + 2, yPx + 2, cellPx - 4, cellPx - 4);
            ctx.shadowBlur = 0;
          }
        }
      }
      for (let arrow of arrows) {
        let px = (arrow.x - sx) * cellPx + cellPx / 2;
        let py = (arrow.y - sy) * cellPx + cellPx / 2;
        if (px >= 0 && px <= canvasPx && py >= 0 && py <= canvasPx) {
          ctx.fillStyle = "yellow";
          ctx.beginPath();
          ctx.arc(px, py, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      for (let [id, player] of players) {
        let px = (player.x - sx) * cellPx + cellPx / 2;
        let py = (player.y - sy) * cellPx + cellPx / 2;
        if (px >= 0 && px <= canvasPx && py >= 0 && py <= canvasPx) {
          ctx.fillStyle = player.color;
          ctx.font = "26px monospace";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
          ctx.shadowBlur = 3;
          ctx.fillText("@", px, py);
          ctx.shadowBlur = 0;
          if (player.name) {
            ctx.font = "12px monospace";
            ctx.fillStyle = "white";
            ctx.fillText(player.name, px, py - 20);
            ctx.fillText(`HP: ${player.hp}`, px, py - 35);
          }
        }
      }
      for (let [id, player] of players) {
        let px = (player.x - sx) * cellPx + cellPx / 2;
        let py = (player.y - sy) * cellPx + cellPx / 2;
        if (px >= 0 && px <= canvasPx && py >= 0 && py <= canvasPx) {
          if (messages.has(id)) {
            const playerMessages = messages.get(id);
            const maxWidth = cellPx * 3;
            let totalHeight = 0;
            const lineHeight = 15;
            for (let i = 0; i < playerMessages.length; i++) {
              const lines = wrapText(playerMessages[i].text, maxWidth);
              totalHeight += lines.length * lineHeight + 10;
            }
            let currentY = py - 50 - totalHeight;
            for (let i = 0; i < playerMessages.length; i++) {
              const lines = wrapText(playerMessages[i].text, maxWidth);
              const boxHeight = lines.length * lineHeight + 10;
              const boxWidth = maxWidth + 10;
              ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
              ctx.strokeStyle = "white";
              ctx.lineWidth = 1;
              ctx.fillRect(px - boxWidth / 2, currentY, boxWidth, boxHeight);
              ctx.strokeRect(px - boxWidth / 2, currentY, boxWidth, boxHeight);
              ctx.font = "12px monospace";
              ctx.fillStyle = "white";
              ctx.textBaseline = "middle";
              for (let j = 0; j < lines.length; j++) {
                ctx.fillText(lines[j], px, currentY + 5 + (j + 0.5) * lineHeight);
              }
              currentY += boxHeight + 5;
            }
          }
        }
      }
      document.getElementById("invCount").textContent = `HP: ${me.hp}`;
      document.querySelectorAll('.inventory-slot').forEach((slot, index) => {
        const countEl = slot.querySelector('.count');
        if (countEl) {
          countEl.textContent = inventory[index].count || 0;
        }
      });
    }
    function getCell(x, y) {
      return tiles.get(x + "," + y);
    }
    function canvasMouseDown(e) {
      const me = players.get(myId);
      if (!me || selectedSlot === null) return;
      let rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      let tx = Math.floor(x / cellPx);
      let ty = Math.floor(y / cellPx);
      let targetX = me.x - Math.floor(gridSize / 2) + tx;
      let targetY = me.y - Math.floor(gridSize / 2) + ty;
      if (selectedSlot === 0) { // Блоки
        if (nearby(me.x, me.y, targetX, targetY, 2) && getCell(targetX, targetY) == 0 && inventory[0].count > 0) {
          ws.send(JSON.stringify({ type: 'build', x: targetX, y: targetY }));
        }
      } else if (selectedSlot === 1) { // Меч
        for (let [id, player] of players) {
          if (id !== myId && nearby(me.x, me.y, player.x, player.y, 1)) {
            ws.send(JSON.stringify({ type: 'damage', targetId: id, damage: 10 }));
            break;
          }
        }
      } else if (selectedSlot === 2) { // Кирка
        if (nearby(me.x, me.y, targetX, targetY, 1) && getCell(targetX, targetY) == 1) {
          ws.send(JSON.stringify({ type: 'break', x: targetX, y: targetY }));
        }
      } else if (selectedSlot === 3) { // Лук
        ws.send(JSON.stringify({ type: 'arrow', x: me.x, y: me.y, targetX, targetY }));
      } else if (selectedSlot === 4) { // Еда
        ws.send(JSON.stringify({ type: 'heal', amount: 10 }));
      }
    }
    document.getElementById('sendChat').addEventListener('click', () => {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      if (text) {
        ws.send(JSON.stringify({ type: 'chat', text }));
        input.value = '';
      }
    });
    document.getElementById('chatInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const input = document.getElementById('chatInput');
        const text = input.value.trim();
        if (text) {
          ws.send(JSON.stringify({ type: 'chat', text }));
          input.value = '';
        }
      }
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'q' || e.key === 'Q') {
        document.getElementById('chatInput').focus();
      }
      if (['w', 'W', 's', 'S', 'a', 'A', 'd', 'D'].includes(e.key)) {
        keysPressed.add(e.key);
      }
      if (['1', '2', '3', '4', '5'].includes(e.key)) {
        selectedSlot = parseInt(e.key) - 1;
        document.querySelectorAll('.inventory-slot').forEach(slot => slot.classList.remove('selected'));
        document.querySelector(`.inventory-slot[data-slot="${selectedSlot}"]`).classList.add('selected');
      }
    });
    document.addEventListener('keyup', (e) => {
      keysPressed.delete(e.key);
    });
    const dpadButtons = document.querySelectorAll('.dpad-button');
    dpadButtons.forEach(button => {
      button.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const dir = button.getAttribute('data-dir');
        if (dir) moveWithDpad(dir);
      });
    });
    const inventorySlots = document.querySelectorAll('.inventory-slot');
    inventorySlots.forEach(slot => {
      slot.addEventListener('click', () => {
        selectedSlot = parseInt(slot.getAttribute('data-slot'));
        inventorySlots.forEach(s => s.classList.remove('selected'));
        slot.classList.add('selected');
      });
    });
    canvas.onmousedown = canvasMouseDown;
    canvas.ontouchstart = (e) => {
      e.preventDefault();
      let touch = e.touches[0];
      let mouseDown = new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseDown);
    };
  </script>
</body>
</html>
